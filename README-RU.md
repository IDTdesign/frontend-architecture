# Архитектура фронтенда

## Цель

Сделать вёрстку управляемой, транспортабельной и кастомизируемой. Решить существующие проблемы.

### Какие проблемы решаем

* Глобальными переменными тяжело управлять: их слишком много, страшно менять переменные, т.к. это может зацепить другие компоненты в непредсказуемых местах. В результате создаем еще больше похожих глобальных переменных.
* Нынешнее разбиение на компоненты не годится: они получились слишком большими, в них тяжело разобраться. При попытке перенести верстку в другой проект переносится много лишнего кода.
* Верстка не документирована, нет примеров использования: зачастую конкретным компонентом пользуется только автор, остальные пишут свои похожие компоненты и пользуются только ими. Кодовая база растёт, а совместное владение кодом понижается.
* Низкая транспортабельность кода: нельзя просто так взять и перенести компонент из проекта в проект. Из-за использования глобальных переменных, которые могут быть не объявлены в новом проекте, компонент не билдится. Приходится разбираться с исходным кодом компонента, а так как они слишком крупные (и часто в одном файле содержится несколько модулей), то разбираться с компонентами долго и лень.
* Не предусмотрена кастомизация внешнего вида: в новом проекте компонент можно кастомизировать только с помощью глобальных переменных, но их недостаточно. Бывает, что перенесённый компонент уже содержит скин, который нужно обнулять. Тогда приходится менять код самого компонента, а не добавлять новые стили через класс-модификатор. В результате у нас появляется дубликат компонента с новым внешним видом.

## Терминология

> Компонент — это решение технологической задачи с помощью HTML/CSS/JS. В терминах БЭМ — это независимый блок. Компонент решает техническую задачу: например, типографика, элементы форм, выпадающее меню, прижатый к низу окна футер и т.д.

Компонент и модуль не одно и то же.

> Модуль — это готовый кусок интерфейса, который может быть собран из нескольких компонентов, как из элементов конструктора. Модуль решает интерфейсную задачу (задачу более высокого уровня): хеадер, навигация, блок с отзывами, футер.

Обычно компонент — более мелкая единица, чем модуль. Иногда компонент = модулю: задача модуля решается одним единственным компонентом.

### Кулинарная аналогия (just for fun)

Компоненты — это вода, мука, молоко, яйца, сахар, соль, сода, уксус и т.д. Каждый компонент решает свою технологическую задачу.

Тесто — это модуль. Модуль может состоять из нескольких компонентов. Модуль решает UX задачу (слепить булочку).

Булочка — это продукт (страница сайта). Продукт решает задачу пользователя.

Иногда UX задачу можно решить с помощью единственного компонента. Например, задача «подсластить булочку» полностью решается с помощью компонента «сахар»: сахарная пудра — это сахар с модификатором «очень мелкий». В этом случае модуль равен компоненту.

## Компонентный подход

Новый компонентный подход призван решить проблемы с лишним кодом и низкой транспортабельностью компонентов между проектами.

> Лучше делать маленькие компоненты

Маленькими компонентами легче управлять, к ним проще написать документацию, и в итоге ими легче пользоваться.

Насколько маленькими делать компоненты?

Идеально, чтобы компонент решал одну задачу. Если задача может быть решена несколькими способами, у компонента появляются модификаторы для настройки.

> Делать конструктор из мелких делатей

Вместо сложного компонента с множеством модификаторов и зависисмостей лучше сделать три-четыре более мелких и простых независимых компонента и с их помощью собрать модуль с нужным функционалом.

Нужно ли документировать модули?

Нужно! В документации проекта создать шаблоны типовых модулей (хеадер, меню, футер, форма логина и т.д.), описать, какими классами в каких местах их можно модифицировать.

Модули, в отличие от компонентов, относятся к проекту. Компоненты можно использовать в разных проектах.

> Если компонент слишком сильно изменился, то это новый компонент

В процессе жизни компоненты могут видоизменяться: совершенствоваться, расширяться новыми модификаторами. Нужно уловить момент, когда компонент вместо совершенствования начинает мутировать или совершает эволюционный скачок.

Если компонент начинает решать другую задачу, это уже новый компонент (мутация).

Если компонент начинает решать ту же задачу принципиально иным способом (например, новая CSS технология), то это уже новый компонент (эволюционный скачок).

Новый компонент должен существовать параллельно со старым. Старый должен оставаться для совместимости, пока используется хоть на одном проекте.

## Структура компонента

Рассмотрим минимальную обязательную структуру компонента.

Пусть `mycomponent` — имя компонента. Компонент хранится в файле `_mycomponent.less`.

```less
// _mycomponent.less
@mycomponent: mycomponent;

.mycomponent-settings() {
    @color: blue;
    @margin: 1em 0;
}

.@{mycomponent} {
    color: @color;
    margin: @margin;

    &-part {
        text-transform: capitalize;
        color: @color;
        margin: @margin;
    }

    .mycomponent-settings();
}

// _mycomponent.less EOF
```
В начале файла располагаются настройки компонента (чтобы были на виду).

`@mycomponent: mycomponent;` — объявим имя компонента как переменную. Это единственная глобальная переменная компонента. Она нужна, чтобы была возможность переименовать класс компонента (об этом ниже).

Далее идет миксин с локальными переменными:

```less
.mycomponent-settings() {
    @color: blue;
    ...
}
```

После настроек идет код компонента. Базовый класс компонента задан через переменную.

```less
.@{mycomponent} {
    ...
}
```

Внутри базового класса все элементы, которые использует имя компонента как часть своего имени класса, вызываются через `&`. Например:

```less
.@{mycomponent} {
    ...

    &:hover { ... }
    &-part { ... }
    & > .something { ... }

    ...
}
```

В самом конце подключается миксин с переменными:

```less
.@{mycomponent} {
    ...

    .mycomponent-settings();
}
```

### Три причины, почему настройки упакованы в миксин и подключаются в конце

1. **Чтобы переменные были локальными**

    Локальные переменные не смешиваются с переменными других компонентов и можно смело использовать простые имена — `@color`, `@background`, `@border`, `@width` — и не париться насчет конфликтов.
    
2. **Компонент можно перенастроить через миксин с настройками**  

    Миксин является своего рода картриджем. В проектном less-файле можно переопределить любую переменную, и компонент отрендерится с нужными параметрами. А можно ничего не переопределять, всё скомпилируется с дефолтными настройками.
    
3. **Чтобы можно было переопределить другие свойства, не переменные**  

    Для этого миксин подключается в самом конце. В миксине можно дописать любые css-свойства, в том числе для псевдоклассов и вложенных элементов, и они отрендерятся в самом безопасном месте — сразу после кода модуля.

### Компонент можно переименовать с помощью глобальной переменной

## Разделение на «геометрию» и «скин»

## Документация

## Импорт компонента в проект

## Кастомизация компонента

## Библиотека компонентов

## Шаблоны
