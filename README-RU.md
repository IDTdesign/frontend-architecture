# Архитектура фронтенда

## Цель

Сделать вёрстку управляемой, транспортабельной и кастомизируемой. Решить существующие проблемы.

### Какие проблемы решаем

* Глобальными переменными тяжело управлять: их слишком много, страшно менять переменные, т.к. это может зацепить другие компоненты в непредсказуемых местах. В результате создаем еще больше похожих глобальных переменных.
* Нынешнее разбиение на компоненты не годится: они получились слишком большими, в них тяжело разобраться. При попытке перенести верстку в другой проект переносится много лишнего кода.
* Верстка не документирована, нет примеров использования: зачастую конкретным компонентом пользуется только автор, остальные пишут свои похожие компоненты и пользуются только ими. Кодовая база растёт, а совместное владение кодом понижается.
* Низкая транспортабельность кода: нельзя просто так взять и перенести компонент из проекта в проект. Из-за использования глобальных переменных, которые могут быть не объявлены в новом проекте, компонент не билдится. Приходится разбираться с исходным кодом компонента, а так как они слишком крупные (и часто в одном файле содержится несколько модулей), то разбираться с компонентами долго и лень.
* Не предусмотрена кастомизация внешнего вида: в новом проекте компонент можно кастомизировать только с помощью глобальных переменных, но их недостаточно. Бывает, что перенесённый компонент уже содержит скин, который нужно обнулять. Тогда приходится менять код самого компонента, а не добавлять новые стили через класс-модификатор. В результате у нас появляется дубликат компонента с новым внешним видом.

## Терминология

> Компонент — это решение технологической задачи с помощью HTML/CSS/JS. В терминах БЭМ — это независимый блок. Компонент решает техническую задачу: например, типографика, элементы форм, выпадающее меню, прижатый к низу окна футер и т.д.

Компонент и модуль не одно и то же.

> Модуль — это готовый кусок интерфейса, который может быть собран из нескольких компонентов, как из элементов конструктора. Модуль решает интерфейсную задачу (задачу более высокого уровня): хеадер, навигация, блок с отзывами, футер.

Обычно компонент — более мелкая единица, чем модуль. Иногда компонент = модулю: задача модуля решается одним единственным компонентом.

### Кулинарная аналогия (just for fun)

Компоненты — это вода, мука, молоко, яйца, сахар, соль, сода, уксус и т.д. Каждый компонент решает свою технологическую задачу.

Тесто — это модуль. Модуль может состоять из нескольких компонентов. Модуль решает UX задачу (слепить булочку).

Булочка — это продукт (страница сайта). Продукт решает задачу пользователя.

Иногда UX задачу можно решить с помощью единственного компонента. Например, задача «подсластить булочку» полностью решается с помощью компонента «сахар»: сахарная пудра — это сахар с модификатором «очень мелкий». В этом случае модуль равен компоненту.

## Компонентный подход

Новый компонентный подход призван решить проблемы с лишним кодом и низкой транспортабельностью компонентов между проектами.

> Лучше делать маленькие компоненты

Маленькими компонентами легче управлять, к ним проще написать документацию, и в итоге ими легче пользоваться.

Насколько маленькими делать компоненты?

Идеально, чтобы компонент решал одну задачу. Если задача может быть решена несколькими способами, у компонента появляются модификаторы для настройки.

> Делать конструктор из мелких делатей

Вместо сложного компонента с множеством модификаторов и зависисмостей лучше сделать три-четыре более мелких и простых независимых компонента и с их помощью собрать модуль с нужным функционалом.

Нужно ли документировать модули?

Нужно! В документации проекта создать шаблоны типовых модулей (хеадер, меню, футер, форма логина и т.д.), описать, какими классами в каких местах их можно модифицировать.

Модули, в отличие от компонентов, относятся к проекту. Компоненты можно использовать в разных проектах.

> Если компонент слишком сильно изменился, то это новый компонент

В процессе жизни компоненты могут видоизменяться: совершенствоваться, расширяться новыми модификаторами. Нужно уловить момент, когда компонент вместо совершенствования начинает мутировать или совершает эволюционный скачок.

Если компонент начинает решать другую задачу, это уже новый компонент (мутация).

Если компонент начинает решать ту же задачу принципиально иным способом (например, новая CSS технология), то это уже новый компонент (эволюционный скачок).

Новый компонент должен существовать параллельно со старым. Старый должен оставаться для совместимости, пока используется хоть на одном проекте.

## Структура компонента

### Компонент можно перенастроить через миксин с настройками

### Компонент можно переименовать с помощью глобальной переменной

## Разделение на «геометрию» и «скин»

## Документация

## Импорт компонента в проект

## Кастомизация компонента

## Библиотека компонентов

## Шаблоны
